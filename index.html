<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Glue Project</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .main-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 20px;
        }
        
        .title {
            font-size: 2.5rem;
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 30px;
            text-align: center;
        }
        
        canvas {
            border: 4px solid #2d3748;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            background: #000;
        }
        
        .instructions {
            color: #cbd5e0;
            margin-top: 20px;
            font-size: 1rem;
            text-align: center;
        }
        
        .sidebar {
            width: 320px;
            background: #2d3748;
            padding: 20px;
            overflow-y: auto;
        }
        
        .section {
            background: #1a202c;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            border: 1px solid #4a5568;
        }
        
        .section-title {
            color: #ffffff;
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 12px;
        }
        
        button {
            width: 100%;
            padding: 10px 16px;
            font-size: 0.95rem;
            font-weight: 500;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 8px;
        }
        
        button:hover {
            transform: translateY(-1px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .btn-blue {
            background: #4299e1;
            color: white;
        }
        
        .btn-blue:hover {
            background: #3182ce;
        }
        
        .btn-amber {
            background: #ed8936;
            color: white;
        }
        
        .btn-amber:hover {
            background: #dd6b20;
        }
        
        .btn-red {
            background: #f56565;
            color: white;
        }
        
        .btn-red:hover {
            background: #e53e3e;
        }
        
        .btn-purple {
            background: #9f7aea;
            color: white;
        }
        
        .btn-purple:hover {
            background: #805ad5;
        }
        
        .btn-teal {
            background: #38b2ac;
            color: white;
        }
        
        .btn-teal:hover {
            background: #319795;
        }
        
        .btn-gray {
            background: #718096;
            color: white;
        }
        
        .btn-gray:hover {
            background: #4a5568;
        }
        
        .btn-green {
            background: #48bb78;
            color: white;
            padding: 10px 16px;
            width: auto;
        }
        
        .btn-green:hover {
            background: #38a169;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            color: white;
            cursor: pointer;
            padding: 8px;
            background: #2d3748;
            border-radius: 6px;
            transition: background 0.2s ease;
        }
        
        .checkbox-label:hover {
            background: #4a5568;
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 10px;
            cursor: pointer;
        }
        
        .label-text {
            color: #a0aec0;
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 8px;
            display: block;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #4a5568;
            border-radius: 4px;
            outline: none;
            margin-bottom: 12px;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: #4299e1;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #4299e1;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        select, input[type="number"] {
            width: 100%;
            padding: 10px;
            background: #2d3748;
            color: white;
            border: 1px solid #4a5568;
            border-radius: 6px;
            font-size: 0.9rem;
            margin-bottom: 10px;
            outline: none;
            transition: border 0.2s ease;
        }
        
        select:focus, input[type="number"]:focus {
            border-color: #4299e1;
        }
        
        .info-box {
            background: #2d3748;
            color: #68d391;
            padding: 8px;
            border-radius: 6px;
            font-size: 0.875rem;
            margin-top: 8px;
            font-weight: 500;
        }
        
        .hint {
            background: #2d3748;
            color: #a0aec0;
            padding: 8px;
            border-radius: 6px;
            font-size: 0.75rem;
            margin-top: 8px;
        }
        
        .flex-row {
            display: flex;
            gap: 8px;
        }
        
        .flex-1 {
            flex: 1;
        }
        
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #2d3748;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #4a5568;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #718096;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script>
        const { useState, useEffect, useRef, createElement: h } = React;

        const GravityPlayground = () => {
          const canvasRef = useRef(null);
          const [gravity, setGravity] = useState(0.3);
          const [selectedPlanet, setSelectedPlanet] = useState('earth');
          const [customValue, setCustomValue] = useState('0.3');
          const [playerSpeed, setPlayerSpeed] = useState(0.4);
          const [playerMass, setPlayerMass] = useState(2);
          const playerRef = useRef({
            x: 150,
            y: 150,
            vx: 0,
            vy: 0,
            width: 30,
            height: 30,
            grounded: false,
            mass: 2
          });
          const [objects, setObjects] = useState([]);
          const keysRef = useRef({});
          const [showTrails, setShowTrails] = useState(true);
          const trailsRef = useRef([]);
          const objectsRef = useRef([]);

          const planets = {
            mercury: { name: 'Mercury', gravity: 0.19 },
            venus: { name: 'Venus', gravity: 0.3 },
            earth: { name: 'Earth', gravity: 0.3 },
            moon: { name: 'Moon', gravity: 0.05 },
            mars: { name: 'Mars', gravity: 0.15 },
            jupiter: { name: 'Jupiter', gravity: 0.8 },
            saturn: { name: 'Saturn', gravity: 0.4 },
            uranus: { name: 'Uranus', gravity: 0.35 },
            neptune: { name: 'Neptune', gravity: 0.4 },
            pluto: { name: 'Pluto', gravity: 0.02 },
            space: { name: 'Zero Gravity', gravity: 0 },
            reverse: { name: 'Reverse Gravity', gravity: -0.3 }
          };

          useEffect(() => {
            const handleKeyDown = (e) => {
              keysRef.current[e.key.toLowerCase()] = true;
              if (e.key === ' ') e.preventDefault();
            };
            const handleKeyUp = (e) => {
              keysRef.current[e.key.toLowerCase()] = false;
            };

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            return () => {
              window.removeEventListener('keydown', handleKeyDown);
              window.removeEventListener('keyup', handleKeyUp);
            };
          }, []);

          useEffect(() => {
            objectsRef.current = objects;
          }, [objects]);

          useEffect(() => {
            playerRef.current.mass = playerMass;
          }, [playerMass]);

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            let animationId;
            let lastTime = performance.now();

            const checkCollision = (a, b) => {
              return a.x < b.x + b.width &&
                     a.x + a.width > b.x &&
                     a.y < b.y + b.height &&
                     a.y + a.height > b.y;
            };

            const resolveCollision = (obj1, obj2) => {
              const dx = (obj1.x + obj1.width / 2) - (obj2.x + obj2.width / 2);
              const dy = (obj1.y + obj1.height / 2) - (obj2.y + obj2.height / 2);
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance === 0) return;
              
              const nx = dx / distance;
              const ny = dy / distance;
              
              const relVelX = obj1.vx - obj2.vx;
              const relVelY = obj1.vy - obj2.vy;
              const velAlongNormal = relVelX * nx + relVelY * ny;
              
              if (velAlongNormal > 0) return;
              
              const bounce = 0.5;
              const mass1 = obj1.mass || 1;
              const mass2 = obj2.mass || 1;
              
              const impulse = (-(1 + bounce) * velAlongNormal) / (1/mass1 + 1/mass2);
              
              obj1.vx += (impulse * nx) / mass1;
              obj1.vy += (impulse * ny) / mass1;
              obj2.vx -= (impulse * nx) / mass2;
              obj2.vy -= (impulse * ny) / mass2;
              
              const overlap = (obj1.width / 2 + obj2.width / 2) - distance;
              const totalWeight = mass1 + mass2;
              obj1.x += nx * overlap * (mass2 / totalWeight);
              obj1.y += ny * overlap * (mass2 / totalWeight);
              obj2.x -= nx * overlap * (mass1 / totalWeight);
              obj2.y -= ny * overlap * (mass1 / totalWeight);
            };

            const update = () => {
              const player = playerRef.current;
              const keys = keysRef.current;

              const moveSpeed = playerSpeed;
              const maxSpeed = 8;
              const jumpPower = 9;

              if (keys['a'] || keys['arrowleft']) player.vx -= moveSpeed;
              if (keys['d'] || keys['arrowright']) player.vx += moveSpeed;
              
              if (keys[' '] && player.grounded) {
                player.vy = -jumpPower;
                player.grounded = false;
              }

              player.vy += gravity;
              player.vx *= 0.88;

              player.vx = Math.max(-maxSpeed, Math.min(maxSpeed, player.vx));
              player.vy = Math.max(-20, Math.min(20, player.vy));

              player.x += player.vx;
              player.y += player.vy;

              player.grounded = false;

              if (player.y + player.height >= canvas.height) {
                player.y = canvas.height - player.height;
                player.vy = 0;
                player.grounded = true;
                player.vx *= 0.8;
              }

              if (player.y <= 0) {
                player.y = 0;
                player.vy *= -0.5;
              }

              if (player.x <= 0) {
                player.x = 0;
                player.vx *= -0.5;
              }
              if (player.x + player.width >= canvas.width) {
                player.x = canvas.width - player.width;
                player.vx *= -0.5;
              }

              const updatedObjects = objectsRef.current.map(obj => {
                const newObj = { ...obj };
                
                newObj.vy += gravity;
                newObj.vx *= 0.99;
                newObj.vy *= 0.995;

                newObj.x += newObj.vx;
                newObj.y += newObj.vy;

                if (newObj.y + newObj.height >= canvas.height) {
                  newObj.y = canvas.height - newObj.height;
                  newObj.vy *= -0.6;
                  newObj.vx *= 0.92;
                  if (Math.abs(newObj.vy) < 0.2) newObj.vy = 0;
                }

                if (newObj.y <= 0) {
                  newObj.y = 0;
                  newObj.vy *= -0.6;
                }

                if (newObj.x <= 0) {
                  newObj.x = 0;
                  newObj.vx *= -0.7;
                }
                if (newObj.x + newObj.width >= canvas.width) {
                  newObj.x = canvas.width - newObj.width;
                  newObj.vx *= -0.7;
                }

                if (checkCollision(player, newObj)) {
                  resolveCollision(player, newObj);
                }

                return newObj;
              });

              for (let i = 0; i < updatedObjects.length; i++) {
                for (let j = i + 1; j < updatedObjects.length; j++) {
                  if (checkCollision(updatedObjects[i], updatedObjects[j])) {
                    resolveCollision(updatedObjects[i], updatedObjects[j]);
                  }
                }
              }

              setObjects(updatedObjects);

              if (showTrails && (Math.abs(player.vx) > 0.3 || Math.abs(player.vy) > 0.3)) {
                trailsRef.current.push({
                  x: player.x + player.width / 2,
                  y: player.y + player.height / 2,
                  life: 25
                });
                if (trailsRef.current.length > 40) trailsRef.current.shift();
              }
            };

            const draw = () => {
              const player = playerRef.current;

              ctx.fillStyle = '#0a0a0a';
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              ctx.strokeStyle = '#1a1a1a';
              ctx.lineWidth = 1;
              for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
              }
              for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
              }

              if (showTrails) {
                trailsRef.current = trailsRef.current.filter(t => t.life > 0);
                trailsRef.current.forEach(trail => {
                  trail.life--;
                  const alpha = trail.life / 25;
                  ctx.fillStyle = `rgba(100, 200, 255, ${alpha * 0.6})`;
                  ctx.beginPath();
                  ctx.arc(trail.x, trail.y, 6, 0, Math.PI * 2);
                  ctx.fill();
                });
              }

              objectsRef.current.forEach(obj => {
                if (obj.type === 'rock') {
                  const gradient = ctx.createRadialGradient(
                    obj.x + obj.width / 2, obj.y + obj.height / 2, 5,
                    obj.x + obj.width / 2, obj.y + obj.height / 2, obj.width / 2
                  );
                  gradient.addColorStop(0, '#a0826d');
                  gradient.addColorStop(1, '#6b5d54');
                  ctx.fillStyle = gradient;
                  ctx.beginPath();
                  ctx.arc(obj.x + obj.width / 2, obj.y + obj.height / 2, obj.width / 2, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.strokeStyle = '#4a3f37';
                  ctx.lineWidth = 2;
                  ctx.stroke();
                } else if (obj.type === 'square') {
                  const gradient = ctx.createLinearGradient(obj.x, obj.y, obj.x + obj.width, obj.y + obj.height);
                  gradient.addColorStop(0, '#ff6b6b');
                  gradient.addColorStop(1, '#c92a2a');
                  ctx.fillStyle = gradient;
                  ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                  ctx.strokeStyle = '#8b1e1e';
                  ctx.lineWidth = 2;
                  ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                } else if (obj.type === 'triangle') {
                  const centerX = obj.x + obj.width / 2;
                  const centerY = obj.y + obj.height / 2;
                  ctx.fillStyle = '#9f7aea';
                  ctx.beginPath();
                  ctx.moveTo(centerX, obj.y);
                  ctx.lineTo(obj.x + obj.width, obj.y + obj.height);
                  ctx.lineTo(obj.x, obj.y + obj.height);
                  ctx.closePath();
                  ctx.fill();
                  ctx.strokeStyle = '#6b46c1';
                  ctx.lineWidth = 2;
                  ctx.stroke();
                } else if (obj.type === 'pole') {
                  const gradient = ctx.createLinearGradient(obj.x, obj.y, obj.x + obj.width, obj.y);
                  gradient.addColorStop(0, '#4fd1c5');
                  gradient.addColorStop(1, '#38b2ac');
                  ctx.fillStyle = gradient;
                  ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                  ctx.strokeStyle = '#2c7a7b';
                  ctx.lineWidth = 2;
                  ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                }
              });

              const gradient = ctx.createLinearGradient(player.x, player.y, player.x + player.width, player.y + player.height);
              gradient.addColorStop(0, '#5dade2');
              gradient.addColorStop(1, '#2874a6');
              ctx.fillStyle = gradient;
              ctx.fillRect(player.x, player.y, player.width, player.height);
              ctx.strokeStyle = '#1a5276';
              ctx.lineWidth = 2;
              ctx.strokeRect(player.x, player.y, player.width, player.height);

              ctx.fillStyle = '#fff';
              ctx.fillRect(player.x + 6, player.y + 8, 6, 6);
              ctx.fillRect(player.x + 18, player.y + 8, 6, 6);

              ctx.fillStyle = '#000';
              ctx.fillRect(player.x + 8, player.y + 10, 3, 3);
              ctx.fillRect(player.x + 20, player.y + 10, 3, 3);

              if (player.grounded) {
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(player.x, player.y + player.height + 3, player.width, 3);
              }
            };

            const gameLoop = () => {
              const currentTime = performance.now();
              const deltaTime = currentTime - lastTime;
              
              if (deltaTime >= 16) {
                update();
                draw();
                lastTime = currentTime;
              }
              
              animationId = requestAnimationFrame(gameLoop);
            };

            gameLoop();
            return () => cancelAnimationFrame(animationId);
          }, [gravity, showTrails, playerSpeed]);

          const reset = () => {
            playerRef.current = { x: 150, y: 150, vx: 0, vy: 0, width: 30, height: 30, grounded: false, mass: playerMass };
            trailsRef.current = [];
          };

          const handlePlanetChange = (planetKey) => {
            setSelectedPlanet(planetKey);
            const newGravity = planets[planetKey].gravity;
            setGravity(newGravity);
            setCustomValue(newGravity.toString());
          };

          const applyCustomGravity = () => {
            const val = parseFloat(customValue);
            if (!isNaN(val) && val >= -3 && val <= 3) {
              setGravity(val);
              setSelectedPlanet('custom');
            }
          };

          const addObject = (type) => {
            let size, width, height;
            if (type === 'pole') {
              width = 20;
              height = 80;
            } else {
              size = type === 'rock' ? 35 : 40;
              width = size;
              height = size;
            }
            
            const newObj = {
              id: Date.now() + Math.random(),
              type: type,
              x: Math.random() * (750 - width - 100) + 50,
              y: -height,
              vx: (Math.random() - 0.5) * 3,
              vy: 0,
              width: width,
              height: height,
              mass: type === 'rock' ? 1.5 : type === 'triangle' ? 1.2 : type === 'pole' ? 2.5 : 1
            };
            setObjects(prev => [...prev, newObj]);
          };

          const clearObjects = () => {
            setObjects([]);
          };

     return h('div', { className: 'container' },
            h('div', { className: 'main-content' },
              h('h1', { className: 'title' }, 'Space glue project'),
              h('canvas', {
                ref: canvasRef,
                width: 750,
                height: 500
              }),
              h('p', { className: 'instructions' }, 'A/D or Arrow Keys = Move | Spacebar = Jump | Higher mass = push objects harder')
            ),
            h('div', { className: 'sidebar' },
              h('div', { className: 'section' },
                h('h3', { className: 'section-title' }, 'Controls'),
                h('button', {
                  onClick: reset,
                  className: 'btn-blue'
                }, 'Reset Position'),
                h('label', { className: 'checkbox-label' },
                  h('input', {
                    type: 'checkbox',
                    checked: showTrails,
                    onChange: (e) => setShowTrails(e.target.checked)
                  }),
                  'Show Trails'
                )
              ),
              h('div', { className: 'section' },
                h('h3', { className: 'section-title' }, 'Player Settings'),
                h('label', { className: 'label-text' }, 
                  'Speed: ' + playerSpeed.toFixed(2)
                ),
                h('input', {
                  type: 'range',
                  min: '0.1',
                  max: '1',
                  step: '0.05',
                  value: playerSpeed,
                  onChange: (e) => setPlayerSpeed(parseFloat(e.target.value))
                }),
                h('label', { className: 'label-text' },
                  'Mass: ' + playerMass.toFixed(1)
                ),
                h('input', {
                  type: 'range',
                  min: '0.5',
                  max: '5',
                  step: '0.5',
                  value: playerMass,
                  onChange: (e) => setPlayerMass(parseFloat(e.target.value))
                }),
              ),
              h('div', { className: 'section' },
                h('h3', { className: 'section-title' }, 'Gravity'),
                h('select', {
                  value: selectedPlanet,
                  onChange: (e) => handlePlanetChange(e.target.value)
                }, Object.keys(planets).map(key =>
                  h('option', { key: key, value: key },
                    planets[key].name + ' - ' + planets[key].gravity
                  )
                )),
              ),
              h('div', { className: 'section' },
                h('h3', { className: 'section-title' }, 'Custom Gravity'),
                h('input', {
                  type: 'range',
                  min: '-3',
                  max: '3',
                  step: '0.05',
                  value: gravity,
                  onChange: (e) => {
                    const val = parseFloat(e.target.value);
                    setGravity(val);
                    setCustomValue(val.toString());
                    setSelectedPlanet('custom');
                  }
                }),
                h('div', { className: 'flex-row' },
                  h('input', {
                    type: 'number',
                    value: customValue,
                    onChange: (e) => setCustomValue(e.target.value),
                    step: '0.1',
                    className: 'flex-1'
                  }),
                  h('button', {
                    onClick: applyCustomGravity,
                    className: 'btn-green'
                  }, 'Set')
                )
              ),
              h('div', { className: 'section' },
                h('h3', { className: 'section-title' }, 'Add Objects'),
                h('button', {
                  onClick: () => addObject('rock'),
                  className: 'btn-amber'
                }, 'Add Rock'),
                h('button', {
                  onClick: () => addObject('square'),
                  className: 'btn-red'
                }, 'Add Square'),
                h('button', {
                  onClick: () => addObject('triangle'),
                  className: 'btn-purple'
                }, 'Add Triangle'),
                h('button', {
                  onClick: () => addObject('pole'),
                  className: 'btn-teal'
                }, 'Add Pole'),
                h('button', {
                  onClick: clearObjects,
                  className: 'btn-gray'
                }, 'Clear All (' + objects.length + ')')
              )
            )
          );
        };

        ReactDOM.render(h(GravityPlayground), document.getElementById('root'));
    </script>
</body>
</html>
